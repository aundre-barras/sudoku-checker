--------------------------------------------------------------------------

            +-------------------------+
            | CS 450                  |
            | PROJECT: SUDOKU CHECKER |
            | DESIGN DOCUMENT         |
            +-------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Aundre Barras <barras@sonoma.edu>
Paris Osuch <osuch@sonoma.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission or
>> bug notes, please give them here.

None

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than man pages, course
>> text, lecture notes, and course staff.

Three main sources on forking and threading that was consulted was GeeksForGeeks.org, Youtube.com, and Stackoverflow.com.


               THREADED SUDOKU CHECKER
               =======================

---- EXPLORE THE PROBLEM ----

>> A1: Given the problem decomposition described in the requirements
>> for Part A, to achieve the maximum parallelism how many
>> threads would need to be running concurrently?

27 (9 rows, 9 columns, 9 subgrids)

---- DATA STRUCTURES ----

>> A2: Copy here the declaration of each new or changed `struct', 
>> `struct' member, global or static variable, `typedef', or enumeration.
>> Identify the purpose of each in 2--25 words.

// The sudoku board along with a row and col id of the current pointer, 
//  meant to store the data of the entire board and its subgrid
struct sudoku {
    int grid[9][9]; // the grid itself
    int rowID; // the row for the subgrid
    int colID; // the col for the subgrid
};

---- FUNCTIONS ----

>> A3: Provide a prototype and documentation for each function
>> you have introduced to support this portion of the project.
>> Use the Google Style Guide for function documentation.

// Returns a sudoku structure that reads input from standard in.
struct sudoku * readSudokuFile();
// Takes in a sudoku structure and outputs the sudoku grid through standard out.
void printPuzzle(struct sudoku* s);
// Takes in a subgrid sudoku structure, scans the column of the subgrid passed, and
//  returns a status value based on if it is valid or not.
static void *validateCol(void* sdk);
// Takes in a subgrid sudoku structure, scans the row of the subgrid passed, and
//  returns a status value based on if it is valid or not.
static void *validateRow(void* sdk);
// Takes in a subgrid sudoku structure, scans the surrounding grid of the subgrid passed, and
//  returns a status value based on if it is valid or not.
static void *validateSubgrid(void* sdk);
// Takes in a sudoku structure and utilizes linux threading to worker threads for each validator.
//  There is a total of 27 threads created to check if each row, col, and
//  subgrid of the sudoku structure is valid. It returns a boolean value determing whether or not
//  the sudoku structure is valid.
int thread_process(struct sudoku* sdk);
---- ALGORITHMS ----

>> A4: Briefly describe how you communicated to each worker thread
>> the work it should perform, as a void *

To communicate to each worker thread the subgrid it should be using to perform its work,
a copy of the sudoku structure is created. This sudoku structure then has its `colID` and `rowID`
set to the current row and col that the subgrid is looking at. It then scans that subgrid to validate
that row, col, or subgrid.

>> A5: Briefly describe the function(s) run by each worker. Explain
>> if any memory is shared among threads.

The functions ran by each worker are either `validateCol()`, `validateRow()`, or `validateSubgrid()`.
these are the functions being passed to each worker thread to validate the corresponding part of said grid.
The worker accepts an argument of the sudoku structure which then makes a copy of it to iterate over the grid.
The memory being shared between processes would be the sudoku structure itself that is created before calling
the thread creation.

>> A6: Explain how the main thread knows when all the worker
>> threads have completed their work.

The main thread knows when the worker threads have completed their work when calling `pthread_join()`.
This function waits for each thread to finish its work. The work is finished when the function that is being passed into
`pthread_create()` returns a value. This value being a status on the validation of the grid.

>> A7: Explain how the main thread knows when a particular worker
>> thread has reported a property is missing.

The main thread knows when a particular worker thread has reported a property missing when it joins all the
threads together. When joining the thread, a status value is returned which represents a boolean value. This boolean
value determines if the subgrid it was validating is valid or not. 

---- RATIONALE ----

>> A8: Explain how you ensured that your program has no resource leaks.
>> List all the free-able resources and, for each, explain how you
>> free them at the earliest possible time.

The only resource that was needed to be freed at the end of the program was the sudoku structure that
was being created dynamically at the start of each worker thread function. 


               FORKING SUDOKU CHECKER
               =======================

---- EXPLORE THE PROBLEM ----

>> B1: From a design perspective, is there any reason your
>> forking design cannot be as parallel as your threaded
>> solution? If not, how many child processes may be
>> running concurrently at any time?

The forking design cannot be as parallel as the threaded solution because
when you fork a process, it creates a child copy of that same process rather than create an entirely new process.
There should be 27 child processes running concurrently and 1 main process.

---- DATA STRUCTURES ----

>> B2: Copy here the declaration of each new `struct',
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 2--25 words.
>> Do not repeat anything already described in A2.

Same as A2.

---- FUNCTIONS ----

>> B3: Provide a prototype and documentation for each function
>> you have introduced to support this portion of the project.
>> Use the Google Style Guide for function documentation.
>> Do not repeat anything already described in A3.

// Takes in a sudoku structure and utilizes linux forking to create child subprocesses.
//  There is a total of 27 subprocesses created to concurrently check if each row, col, and
//  subgrid of the sudoku structure is valid. It returns a boolean value determing whether or not
//  the sudoku structure is valid.
int fork_process(struct sudoku* sdk);

---- ALGORITHMS ----

>> B4: Briefly describe the method of communicating with each child
>> process and if the function(s) run by each child were different than
>> the functions used by the child threads in Part A.

The functions ran by the child threads in Part A are the same as this part.
They also share the same data structure and communicate the same way, which is sharing
a sudoku structure and creating a copy of that structure to explore the subgrid and validate it.

>> B5: Explain how the parent process knows when all the worker
>> child have completed their work.

The parent process knows when all the child processes have finished their work because the function `fork_process()`
waits for each child process to finish before returning the function.

>> B6: Explain how the parent process knows when a particular worker
>> child has reported a property is missing.

Same as Part A, the functions used to validate each property return a boolean value. This time the child
process exits with a value pertaining to said boolean value from the function.

---- RATIONALE ----

>> B7: Explain how you ensured that your program has no resource leaks.
>> List all the free-able resources and, for each, explain how you
>> free them at the earliest possible time.

The only resource that was needed to be freed at the end of the program was the sudoku structure that
was being created dynamically at the start of each child process. This is a copy of the structure so it is not shared.

               SURVEY QUESTIONS
               ================

>> Answering these questions is optional, but it will help us improve the
>> course in future quarters.  Feel free to tell us anything you
>> want--these questions are just to spur your thoughts.  You may also
>> choose to respond anonymously in the course evaluations at the end of
>> the semester.

>> In your opinion, was this assignment, or any one of the problems
>> in it, too easy or too hard?  Did it take too long or too little time?

It was a fair project. It did not take too long.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

Yes, 100%.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

I think it would be nice to explore more of forking and thread creation in class in the form of code.
Understanding the concepts behind it was not too bad, but it got tricky when trying to create and join threads. Along
with the forking. We weren't entirely sure we were creating processes correctly. It would be nice to have more in depth and 
complex code examples of forking and such.

>> Any other comments?

No.